# Vue.js-Study  

## 뷰 인스턴스
필수적으로 생성해야 하는 기본 단위  
  ```
  new Vue({  
    ...  
  });
  ```
  
* 자주 쓰이는 속성들
1. el: 그려질 위치의 돔 요소 지정 #으로 검색
2. data: 데이터 전달
3. template: 화면에 표시할 속성
4. methods: 화면 로직 제어와 관계된 메서드를 정의
5. created: 뷰 인스턴스가 생성되자마자 실행할 로직을 정의 

## 뷰 컴포넌트 
조합하여 화면을 구성할 수 있는 블록  

* 전역 컴포넌트 등록
```
<script>
Vue.component('컴포넌트 이름', {
//컴포넌트 내용
});
</script>
```
모든 범위에서 사용 가능하다.  

* 지역 컴포넌트 등록
```
<script>
new Vue({
  el : '#app',
  components : {
    '컴포넌트 이름': 컴포넌트 내용
  }
});
</script>
```
el 속성으로 지정해준 범위에서만 사용 가능하다.  

## 뷰 컴포넌트 통신
* 상위-하위 컴포넌트 관계  
전역, 지역 컴포넌트를 등록하면 자연스럽게 하위 컴포넌트가 된다.  
하위 컴포넌트를 등록한 인스턴스는 상위 컴포넌트가 된다.  

* 상위에서 하위 컴포넌트로 데이터 전달  
<strong>props 속성</strong>  
```
Vue.component('child-component', {
  props: ['props 속성 이름'],
});
//전역 또는 지역의 하위 컴포넌트의 속성에 props속성을 정의
```
```
<child-component v-bind:"하위 컴포넌트의 props 속성 이름"="상위 컴포넌트의 data 속성"></child-component>
//child-component 컴포넌트 태그에 v-bind 속성을 추가 -> 하위 컴포넌트의 props 속성이름 = 상위 컴포넌트의 data 속성
```
컴포넌트를 등록함과 동시에 뷰 인스턴스 자체가 상위 컴포넌트가 되기 때문. 
* 하위에서 상위 컴포넌트로 이벤트 전달하기
이벤트를 발생시켜 하위에서 상위로 통신한다.  
데이터를 전달하고 싶다면 이벤트 버스를 이용  
```
//하위 컴포넌트의 이벤트 발생시키기
method: {
  showLog: function() {
    this.$emit('show-log');
  }
}
```
```
<child-component v-on:show-log="printText"></child-component>
//v-on속성을 통해 하위 컴포넌트의 이벤트명과 상위 컴포넌트의 메서드명을 "="을 통해 연결 시킨다.
```
* 관계 없는 컴포넌트 간 통신 - 이벤트 버스
```
//이벤트 버스를 위한 추가 인스턴스 1개 생성
var eventBus = new Vue();
```
```
//이벤트를 보내는 컴포넌트
methods: {
  메서드명 : function() {
    eventBus.$emit('이벤트명', 데이터);
  }
}
```
```
//이벤트를 받는 컴포넌트
methods: {
  created: function() {
    eventBus.$on('이벤트명', function(데이터) {
      ...
    });
  }
}
```
## 뷰 라우터
뷰에서 라우팅 기능을 구현 할 수 있도록 지원하는 공식 라이브러리  

* 라우팅  
웹페이지 간의 이동 방법. 주로 <strong>SPA</strong>에서 사용 한다.

*싱글 페이지 애플리케이션(SPA): 서버에 웹페이지 요청을 하여 갱신하는 것이 아닌   
미리 해당 페이지들을 받아 놓고 페이지 이동 시에 라우팅을 이용하여 화면을 갱신*

* 라우터 구현을 위한 특수태그와 기능
1. <router-link to="URL값">: 페이티 이동 태그. 화면에서는 <a>로 표시, 클릭하면 지정 URL로 이동
2. <router-view>: 페이지 표시 태그. 변경되는 URL에 따라 해당 컴포넌트를 뿌려주는 영역(갱신되는 화면 영역) 

```$mount('영역')```
el 속성과 동일하게 인스턴스를 화면에 붙이는 역할  
인스턴스를 생성할 때 el 속성을 넣지 않았더라도 생성하고 나서 mount속성을 이용해 강제로 화면에 붙일 수 있다.
```
var router = new VueRouter({
  mode: 'history',
  routes
});
```
뷰 URL의 해시 값(#)을 없애고 싶다면 위처럼 histroy모드를 사용하면 된다.  
* 네스티드 라우터  
특정 페이지로 이동할 때 최소 2개 이상의 컴포넌트를 화면에 나타낼 수 있다.  
상위 컴포넌트 1개에 하위 컴포넌트를 포함하는 구조로 구성  
한번에 많은 컴포넌트를 표시하는 데 한계가 있다.
* 네임드 뷰  
특정 페이지로 이동했을 때 여러 개의 컴포넌트를 동시에 표시하는 라우팅 방식  
같은 레밸에서 여러 개의 컴포넌트를 한 번에 표시  

## 뷰 HTTP 통신
웹 앱 HTTP 통신의 대표적인 사례로 제이쿼리의 ajax가 있다.  
ajax는 서버에서 받아온 데이터를 화면 전체를 갱신하지 않고 화면의 일부분만 변경할 수 있게하는 자바스크립트 기법.  
뷰에서도 ajax를 지원하기 위한 라이브러리를 제공 
* axios  
뷰 커뮤니티에서 가장 많이 사용되는 HTTP 통신 라이브러리  
Promise 기반의 API형식을 다양하게 제공해 별도의 로직을 구현할 필요 없다.  

* Promise 기반의 API 형식  
Promise란 서버에 데이터를 요청하여 받아오는 동작과 같은 비동기 로직 처리에 유용한 자바스크립트 객체  
데이터 통신과 관련한 여러 라이브러리 대부분에서 Promise를 활용(axios 포함)  
```
//HTTP GET 요청
axios.get('URL 주소').then().catch();
```
해당 URL주소에 대해 HTTP GET 요청을 보낸다.  
서버에서 보낸 데이터를 정상적으로 받아오면 then()안에 정의한 로직 실행  
오류가 발생하면 catch()에 정의한 로직 수행  
```
//HTTP POST 요청
axios.post('URL 주소').then().catch();
```
```
//HTTP 요청에 대한 옵션 속성 정의
axios({
  method: 'get',
  url: 'URL 주소',
  ...
});
```
HTTP 요청에 대한 자세한 속성들을 직접 정의하여 보낸다.  
데이터 요청을 보낼 URL, HTTP 요청 방식, 보내는 데이터 유형 등등
