# Vue.js-Study  
## 뷰의 장점  
1. 배우기가 쉽다. 앵귤러의 필수 요소들만 가지고 만들었기 때문에 가볍고 크기가 작기 때문.  
2. 리액트와 앵귤러에 비해 성능이 우수하고 빠르다.  
3. 앵귤러의 데이터 바인딩 특성과 리액트의 가상돔 기반 렌더링 특징을 모두 갖고있다.  

## 양방향 데이터 바인딩  
화면에 표시되는 값과 프레임워크 모델 데이터 값이 동기화되어 한쪽이 변경되면 다른 한쪽도 자동으로 변경  

## 단방향 데이터 흐름  
컴포넌트간의 단방향 통신을 의미. 컴포넌트 간에 데이터 전달 시 항상 상위 컴포넌트에서 하위 컴포넌트 한 방향으로 전달.  

## 뷰 컴포넌트 통신  
* 상위-하위 컴포넌트 관계  
전역, 지역 컴포넌트를 등록하면 자연스럽게 하위 컴포넌트가 된다.  
하위 컴포넌트를 등록한 인스턴스는 상위 컴포넌트가 된다.  

* 상위에서 하위 컴포넌트로 데이터 전달  
<strong>props 속성</strong>  
```
Vue.component('child-component', {
  props: ['props 속성 이름'],
});
//전역 또는 지역의 하위 컴포넌트의 속성에 props속성을 정의
```
```
<child-component v-bind:"하위 컴포넌트의 props 속성 이름"="상위 컴포넌트의 data 속성"></child-component>
//child-component 컴포넌트 태그에 v-bind 속성을 추가 -> 하위 컴포넌트의 props 속성이름 = 상위 컴포넌트의 data 속성
```
컴포넌트를 등록함과 동시에 뷰 인스턴스 자체가 상위 컴포넌트가 되기 때문. 
* 하위에서 상위 컴포넌트로 이벤트 전달하기
이벤트를 발생시켜 하위에서 상위로 통신한다.  
데이터를 전달하고 싶다면 이벤트 버스를 이용  
```
//하위 컴포넌트의 이벤트 발생시키기
method: {
  showLog: function() {
    this.$emit('show-log');
  }
}
```
```
<child-component v-on:show-log="printText"></child-component>
//v-on속성을 통해 하위 컴포넌트의 이벤트명과 상위 컴포넌트의 메서드명을 "="을 통해 연결 시킨다.
```
* 관계 없는 컴포넌트 간 통신 - 이벤트 버스
```
//이벤트 버스를 위한 추가 인스턴스 1개 생성
var eventBus = new Vue();
```
```
//이벤트를 보내는 컴포넌트
methods: {
  메서드명 : function() {
    eventBus.$emit('이벤트명', 데이터);
  }
}
```
```
//이벤트를 받는 컴포넌트
methods: {
  created: function() {
    eventBus.$on('이벤트명', function(데이터) {
      ...
    });
  }
}
```
## 뷰 라우터
뷰에서 라우팅 기능을 구현 할 수 있도록 지원하는 공식 라이브러리  

* 라우팅  
웹페이지 간의 이동 방법. 주로 <strong>SPA</strong>에서 사용 한다.

*싱글 페이지 애플리케이션(SPA): 서버에 웹페이지 요청을 하여 갱신하는 것이 아닌   
미리 해당 페이지들을 받아 놓고 페이지 이동 시에 라우팅을 이용하여 화면을 갱신*

* 라우터 구현을 위한 특수태그와 기능
1. <router-link to="URL값">: 페이티 이동 태그. 화면에서는 <a>로 표시, 클릭하면 지정 URL로 이동
2. <router-view>: 페이지 표시 태그. 변경되는 URL에 따라 해당 컴포넌트를 뿌려주는 영역(갱신되는 화면 영역) 

```$mount('영역')```
el 속성과 동일하게 인스턴스를 화면에 붙이는 역할  
인스턴스를 생성할 때 el 속성을 넣지 않았더라도 생성하고 나서 mount속성을 이용해 강제로 화면에 붙일 수 있다.
```
var router = new VueRouter({
  mode: 'history',
  routes
});
```
뷰 URL의 해시 값(#)을 없애고 싶다면 위처럼 histroy모드를 사용하면 된다.  
* 네스티드 라우터  
특정 페이지로 이동할 때 최소 2개 이상의 컴포넌트를 화면에 나타낼 수 있다.  
상위 컴포넌트 1개에 하위 컴포넌트를 포함하는 구조로 구성  
한번에 많은 컴포넌트를 표시하는 데 한계가 있다.
* 네임드 뷰  
특정 페이지로 이동했을 때 여러 개의 컴포넌트를 동시에 표시하는 라우팅 방식  
같은 레밸에서 여러 개의 컴포넌트를 한 번에 표시  

## 뷰 HTTP 통신
웹 앱 HTTP 통신의 대표적인 사례로 제이쿼리의 ajax가 있다.  
ajax는 서버에서 받아온 데이터를 화면 전체를 갱신하지 않고 화면의 일부분만 변경할 수 있게하는 자바스크립트 기법.  
뷰에서도 ajax를 지원하기 위한 라이브러리를 제공 
* axios  
뷰 커뮤니티에서 가장 많이 사용되는 HTTP 통신 라이브러리  
Promise 기반의 API형식을 다양하게 제공해 별도의 로직을 구현할 필요 없다.  

* Promise 기반의 API 형식  
Promise란 서버에 데이터를 요청하여 받아오는 동작과 같은 비동기 로직 처리에 유용한 자바스크립트 객체  
데이터 통신과 관련한 여러 라이브러리 대부분에서 Promise를 활용(axios 포함)  
```
//HTTP GET 요청
axios.get('URL 주소').then().catch();
```
해당 URL주소에 대해 HTTP GET 요청을 보낸다.  
서버에서 보낸 데이터를 정상적으로 받아오면 then()안에 정의한 로직 실행  
오류가 발생하면 catch()에 정의한 로직 수행  
```
//HTTP POST 요청
axios.post('URL 주소').then().catch();
```
```
//HTTP 요청에 대한 옵션 속성 정의
axios({
  method: 'get',
  url: 'URL 주소',
  ...
});
```
HTTP 요청에 대한 자세한 속성들을 직접 정의하여 보낸다.  
데이터 요청을 보낼 URL, HTTP 요청 방식, 보내는 데이터 유형 등등

## Vuex  
상태관리 라이브러리  
```id```
와 같은 특정 데이터를 여러 컴포넌트가 공유하고 있을 때 그 데이터를 상태라고 한다.  
애플리케이션에서 사용하는 모든 데이터를 중앙에서 관리하여 크기가 큰 애플리케이션의 데이터 관리를 효율적으로 함.  

## 뷰의 반응성
뷰가 데이터 변화를 감지했을 때 자동으로 화면을 다시 갱신하는 특성
