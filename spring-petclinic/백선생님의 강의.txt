@SpringBootApplication 에노테이션과
메인 메소드가 들어있는 클래스가 
스프링 부트 기반의 프로젝트에서 메인이 되는 에플리케이션이다.

서버사이드쪽 코드는 메인메소드를 통해 실행해도 다 실행이 되지만
프론트엔드쪽 코드를 수정했을 때는 메이븐으로 실행을 하거나 wro4j를 직접 실행하고
다시 메인에플리케이션을 실행해야 한다.

src/main/java쪽에 소스코드가 들어있고
src/main/less쪽에 뷰관련 파일이 들어있고
src/main/resources에는 리소스가 들어있고
src/test/java에는 테스트 코드가 들어있다

오너가 펫을가지고있고
펫은 여러개의 비짓(방문)을 할수있고
수의사는 여러개의 스페셜티(전공)이 있다.

-IoC(Inversion of Control) Inversion 반전, 뒤집다.
컨트롤이 뒤바꼈다.
주로 의존성에 대한 컨트롤이 뒤바꼈다고 말한다.
원래 의존성에 대한 제어권은 자기 자신이 가지고있었다.
레포지토리가 있어야 컨트롤러를 쓸 수 있다.
의존성을 자기 자신이 관리하던 코드를 뒤바꼈다.
의존성을 내가 관리하지 않고 나 이외에 누가 관리한다.

class OwnerController {
	private OwnerRepository repositroy = new OwnerRepository;
	//본인이 쓸 레포지토리를 본인이 직접 new로 생성하여 쓴다.  기존의 의존성. 제어권을 본인이 가진다.
}
class OwnerController{ 
	private OwnerRepository repo;

	public OwnerController(OwnerRepository repo){
	this.repo = repo;
	//의존성을 본인이 직접 관리하지 않고 나 이외의 누가 관리한다.
	}
}

IoC(Inversion of Control) 컨테이너

스프링 프레임웍은 IoC용 컨테이너를 제공해준다. 
핵심적인 인터페이스가 ApplicationContext(BeanFactory)이다. IoC컨테이너라고 불린다.
직접쓸일은 거의 없다.
위에 코드같은 구조를 동작하게 만들어 준다,
컨트롤러가 IoC컨테이너 내부에 객채로 들어오고
IoC컨테이너 내부에서 컨트롤러 객체를 만들어준다.
그리고 Repository타입의 객체도 만들어준다.
IoC컨테이너가 해주는 일들은 컨테이너 내부에 만든 객체들(빈)의 의존성을 관리해준다.
컨트롤러와 레포지토리도 컨테이너가 만들어주는 빈이다.
둘의 의존성은 IoC컨테이너가 관리해준다. 오로지 빈만 관리해줄 수 있다.
어떤 클래스가 빈이고 어떤 클래스가 빈이아니냐
클래스위에 에노테이션이 붙어있으면 컴포넌트 스캔방식으로 빈으로 등록해준다.
IoC컨테이너 내부에서 객체들을 만들고 의존성을 엮어준다.
빈을 만들고 생성자에 주입을 해준다.
이것들이 IoC컨테이너가 해주는 주요한 일이다.

IoC컨테이너를 굳이 직접 보고싶다면
@Autowired로 직접 꺼낸다.
@Autowired
ApplicationContext applicationContext로 본인을 직접 빈으로 등록해서
applicationContext.getBeen("클래스명.class")로 찍어볼수 있다. 

빈(Bean)
스프링 IoC컨테이너가 관리하는 객체
에노테이션 자체에는 기능이없다.
에노테이션은 주석과 같다.
어디에 붙일것이냐, 어디에 유지할것이냐를 정의하는 것 뿐
에노테이션을 마커로해서 처리하는 프로세스가 있을 뿐이다.
@ComponentScan을 처리하는 애는 컴포넌트 스캔을보면
대부분은 모든 클래스들, 패키지에 @Component를 찾아 빈으로 등록해라.

@Component
1.@Repository
2.@Service
3.@Controller
3개의 에노테이션이 포함된다. 컴포넌트 에노테이션이 붙어있으면 @ComponentScan에 의해
빈으로 등록이 된다. 

또는 빈을 직접 등록하는 방법이있다.
@Bean
public String js(){
	return js;
}
js메소드가 빈으로 등록된다.
@SpringBootApplication은 여러가지 필요한 에노테이션을 합쳐놓은 것이다.
@Configuration이라는 에노테이션이 있는 클래스에다가만 빈을 등록해야 한다.
@SpringBootApplication에 포함되어 있다.

@Autowired를 사용해서 꺼내쓸 수 있다.

@Autowired
String js; ->메소드가 객체로 된다. 게터. 
return "hello "+ js 
hello js 출력

IoC컨테이너는 
오로지 빈들의 의존성만 관리해준다


의존성 주입(Dependency Injection) DI  
@Autowired
@Inject 
두개의 에노테이션을 사용해 주입을 받아 사용한다.

Bean이되는 클래스에에 생성자가 오직 하나만 있고 생성자의 파라미터로 받는 타입이 
빈으로 등록이 되어있다면 @Autowired가 없더라도 주입을 해준다. 생략을 한거다.
JPA에서 Repository는 빈으로 등록된다. Spring JPA가 해주는 것이다. extend Repository를 하면.

@Autowired/@Inject 를 어디에 붙일까?
1.생성자
2.필드
3.세터 
셋다 가능은 함

1순위 생성자
2순위 세터
3순위 필드

@Autowired를 붙이고 싶어서 따로 setter를 만드는것은 과하다
setter가 없다면 필드에 붙여라.
setter로 인해 오히려 의존성이 위험해질수있다.

Aspect 양상
Oriented 지향적인
AOP(Aspect Oriented Programming) 
흩어진 코드를 한곳으로 모으는 코딩 기법.

1.바이트코드를 조작하는방법(.class 조작)
2.프록시패턴을 사용하는 방법

흩어진 코드를 한곳으로 모아오고 그 다른 기타 클래스들은
자신이 해야하는 일만 하도록  
Single Responsibility Principle 객체지향 원칙에 적합하도록 한다. 
객체는 오직 하나의 책임을 져야한다. 한가지 일만 수행해야 한다.

스프링 AOP는 프록시 패턴을 사용한다

@Transactional 에노테이션이 AOP의 예제이다.
@Transactional을 처리하는 코드가 따로 있는 것
에노테이션 자체에 기능이 있는 것은 아니다.

PSA(Portable Service Abstraction) 이식가능한 서비스 추상화, 바꿔끼기 좋은 서비스 추상화
잘만든 인터페이스가 가장 잘 어울린다.
PSA를 쓰면 유지보수가 쉽고 확장성이 좋다.
JDBC -> JPA 이렇게 옮겨도 코드를 수정하지 않아도 된다.

스프링이 제공해주는 PSA는
대부분이다.. 스프링 API의 90퍼센트가 추상화 이다.

트랜잭션


 