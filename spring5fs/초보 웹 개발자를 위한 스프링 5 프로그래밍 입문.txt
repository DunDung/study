@Configuration 애노테이션은 해당 클래스를 스프링 설정 클래스로 지정한다는 뜻
@Configuration 애노테이션이 붙어있는 곳에다만 Bean을 등록할 수 있다.

AnnotationConfigApplicationContext 클래스 -> 객체를 생성하고 초기화 함
ApplicationContext인터페이스를 구현 한 것
AnnotationConfigApplicationContext클래스는 자바 클래스에서 정보를 읽어와 객체 생성과 초기화를 수행한다.
자바파일.class를 파라미터로 넘긴다.
최상위에는 BeanFactory 인터페이스가 있는데
BeanFactory인터페이스는 객체 생성과 검색에 대한 기능을 정의한다. ex).getBean()
이외에도 싱글톤/프로토타입 빈인지 확인하는 기능도 제공한다.
ApplicationContext인터페이스는 메시지, 프로필/환경 변수 등을 처리할 수 있는 기능을 추가로 정의한다.

BeanFactory와 ApplicationContext하단에 위치한 세개의 클래스의 차이점
1.AnnontationConfigApplicationContext : 자바 애노테이션을 이용한 클래스로부터 객체 설정 정보를 가져온다.
2.GenericXmlApplicationContext: XML로부터 객체 설정 정보를 가져온다.
3.GenericGroovyApplicationContext: 그루비 코드를 이용해 설정 정보를 가져온다.

공통점은 설정 정보로부터 빈이라고 불리는 객체를 생성하고 내부에 보관한다. getBean()메소드로 제공한다.

별도의 설정을 하지 않은 경우 스프링은 한 개의 빈 객체만을 생성하며 이때 빈 객체는 '싱글톤 범위를 갖는다'라고
표현한다. 싱글톤은 단일 객체를 의미하는 단어로서
스프링은 기본적으로 한 개의 @Bean 애노테이션에 대해 한개의 빈 객체를 생성한다.

DI는 의존 주입이다
DI를 쓰는 이유 변경의 유연함. 유지보수가 좋다. 객체지향적 설계

조립기(Assembler)는 객체를 생성하고 의존 객체를 주입하는 기능을 제공한다.
또한 객체가 필요한 곳에 객체를 제공한다. 
조립기를 사용하여 코드 변경의 양을 줄인다. 조립기만 변경해주면 된다.
다 조립기에 의존되어 있으니,

스프링에선 조립기를 제공한다.

DI방식
생성자 방식 -> 빈 객체를 생성하는 시점에 모든 의존 객체가 주입된다.
설정 메서드 방식 -> 세터 메서드 이름을 통해 어떤 의존 객체가 주입되는지 알 수 있다.

세터방식의 같은 경우엔 이름만 봐도 어떤 의존 객체를 설정하는지 알 수 있다.
생성자는 편하고

매번 다른 메소드에서
같이 클래스의 객체를 계속 new로 생성하여도
그 객체는 같은 객체를 가리킨다.
스프링 컨테이너가 생성한 빈은 싱글톤 객체이기 때문이다.
@Bean이 붙은 메서드에 대해 한 개의 객체만 생성한다.
스프링이 생성한 객체를 보관했다가 객체생성시에 찾아서 리턴해준다.
고로 메서드를 각각 실행해도 동일한 객체를 사용한다.

@Autowired를 하면
다른 클래스의 Autowired한 필드를 setter로 의존주입을 하지 않아도 된다.

@Import를 사용하면
설정클래스를 나눠 사용할때 하나로 뭉칠 수 있다.
두개 이상의 설정 클래스를 지정할 때는
@Import({A.class, B.class})처럼 배열을 이용해서 저장한다.

의존주입
@Autowired, @Resource, @Inject

@Qualifier 콸리퐈이어 예선이란 뜻.
-자동 주입 가능한 빈이 두 개 이상이면 자동 주입할 빈을 지정할 수 있는 방법.
@Qualifier을 사용하면 자동 주입 대상 빈을 한정할 수 있다.
주입할 빈과 @Autowired할 곳, 두 곳에 붙여준다.
또 빈을 등록할 때 @Qualifier로 이름을 지정해주면
@Autowired는 기본 빈의 이름으로 찾아가고
@Qualifier을 붙인 곳으로 찾아가게 하려면 
@Qualifer("이름")을 @Autowired와같이 선언해줘야 한다.

@Autowired 애노테이션은 기본적으로 @Autowired를 붙인 타입에 해당하는 빈이 존재하지 않으면 익셉션을 발생한다.
하지만 꼭 필요로하지않는 필드라면 그냥 if(null)일때의 코드를 작성하고 Autowired가 되지않았을 때 그 필드가
null이면 된다. 이처럼 @Autowired로 자동 주입할 대상이 필수가 아니라면 required속성을 false로 지정하면 된다.
@Autowired(required = false) -> 매칭되는 빈이 없어도 익셉션이 발생하지 않으며 자동주입 수행안된다.

두번 째 방법으로는 스프링 5버전부터 사용할 수 있는 자바8의 Optional이 있다.
자동주입 대상 타입이 Optional인 경우 일치하는 빈이 존재하지 않으면 값이 없는 Optional을 인자로 전달하여
익셉션을 발생하지 않게하고. 빈이 존재하면 해당 빈을 값으로 갖는 Optional을 인자로 전달한다.

세번 째 방법으로는 @Nullable이 있다. Nullable에노테이션을 의존 주입할 파라미터에 붙이면 빈이 존재하면 해당 빈을
인자로하고 존재하지 않으면 null을 전달한다.

@Autowired(required=false)와 @Nullable의 차이는 세터메소드 호출에 있다.
@Nullable의 경우에는 빈이 없어도 호출은 하고 required는 호출자체를 안한다.
필드에도 적용된다.
required는 인자를 null로 전달도 안하고 @Nullable은 null로 전달을 한다. 
required는 값자체를 할당하지 않는다.
