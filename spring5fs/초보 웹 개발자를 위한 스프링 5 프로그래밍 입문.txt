@Configuration 애노테이션은 해당 클래스를 스프링 설정 클래스로 지정한다는 뜻
@Configuration 애노테이션이 붙어있는 곳에다만 Bean을 등록할 수 있다.

AnnotationConfigApplicationContext 클래스 -> 객체를 생성하고 초기화 함
ApplicationContext인터페이스를 구현 한 것
AnnotationConfigApplicationContext클래스는 자바 클래스에서 정보를 읽어와 객체 생성과 초기화를 수행한다.
자바파일.class를 파라미터로 넘긴다.
최상위에는 BeanFactory 인터페이스가 있는데
BeanFactory인터페이스는 객체 생성과 검색에 대한 기능을 정의한다. ex).getBean()
이외에도 싱글톤/프로토타입 빈인지 확인하는 기능도 제공한다.
ApplicationContext인터페이스는 메시지, 프로필/환경 변수 등을 처리할 수 있는 기능을 추가로 정의한다.

BeanFactory와 ApplicationContext하단에 위치한 세개의 클래스의 차이점
1.AnnontationConfigApplicationContext : 자바 애노테이션을 이용한 클래스로부터 객체 설정 정보를 가져온다.
2.GenericXmlApplicationContext: XML로부터 객체 설정 정보를 가져온다.
3.GenericGroovyApplicationContext: 그루비 코드를 이용해 설정 정보를 가져온다.

공통점은 설정 정보로부터 빈이라고 불리는 객체를 생성하고 내부에 보관한다. getBean()메소드로 제공한다.

별도의 설정을 하지 않은 경우 스프링은 한 개의 빈 객체만을 생성하며 이때 빈 객체는 '싱글톤 범위를 갖는다'라고
표현한다. 싱글톤은 단일 객체를 의미하는 단어로서
스프링은 기본적으로 한 개의 @Bean 애노테이션에 대해 한개의 빈 객체를 생성한다.

DI는 의존 주입이다
DI를 쓰는 이유 변경의 유연함. 유지보수가 좋다. 객체지향적 설계

조립기(Assembler)는 객체를 생성하고 의존 객체를 주입하는 기능을 제공한다.
또한 객체가 필요한 곳에 객체를 제공한다. 
조립기를 사용하여 코드 변경의 양을 줄인다. 조립기만 변경해주면 된다.
다 조립기에 의존되어 있으니,

스프링에선 조립기를 제공한다.

DI방식
생성자 방식 -> 빈 객체를 생성하는 시점에 모든 의존 객체가 주입된다.
설정 메서드 방식 -> 세터 메서드 이름을 통해 어떤 의존 객체가 주입되는지 알 수 있다.

세터방식의 같은 경우엔 이름만 봐도 어떤 의존 객체를 설정하는지 알 수 있다.
생성자는 편하고

매번 다른 메소드에서
같이 클래스의 객체를 계속 new로 생성하여도
그 객체는 같은 객체를 가리킨다.
스프링 컨테이너가 생성한 빈은 싱글톤 객체이기 때문이다.
@Bean이 붙은 메서드에 대해 한 개의 객체만 생성한다.
스프링이 생성한 객체를 보관했다가 객체생성시에 찾아서 리턴해준다.
고로 메서드를 각각 실행해도 동일한 객체를 사용한다.

@Autowired를 하면
다른 클래스의 Autowired한 필드를 setter로 의존주입을 하지 않아도 된다.

@Import를 사용하면
설정클래스를 나눠 사용할때 하나로 뭉칠 수 있다.
두개 이상의 설정 클래스를 지정할 때는
@Import({A.class, B.class})처럼 배열을 이용해서 저장한다.

의존주입
@Autowired, @Resource, @Inject

@Qualifier 콸리퐈이어 예선이란 뜻.
-자동 주입 가능한 빈이 두 개 이상이면 자동 주입할 빈을 지정할 수 있는 방법.
@Qualifier을 사용하면 자동 주입 대상 빈을 한정할 수 있다.
주입할 빈과 @Autowired할 곳, 두 곳에 붙여준다.
또 빈을 등록할 때 @Qualifier로 이름을 지정해주면
@Autowired는 기본 빈의 이름으로 찾아가고
@Qualifier을 붙인 곳으로 찾아가게 하려면 
@Qualifer("이름")을 @Autowired와같이 선언해줘야 한다.

@Autowired 애노테이션은 기본적으로 @Autowired를 붙인 타입에 해당하는 빈이 존재하지 않으면 익셉션을 발생한다.
하지만 꼭 필요로하지않는 필드라면 그냥 if(null)일때의 코드를 작성하고 Autowired가 되지않았을 때 그 필드가
null이면 된다. 이처럼 @Autowired로 자동 주입할 대상이 필수가 아니라면 required속성을 false로 지정하면 된다.
@Autowired(required = false) -> 매칭되는 빈이 없어도 익셉션이 발생하지 않으며 자동주입 수행안된다.

두번 째 방법으로는 스프링 5버전부터 사용할 수 있는 자바8의 Optional이 있다.
자동주입 대상 타입이 Optional인 경우 일치하는 빈이 존재하지 않으면 값이 없는 Optional을 인자로 전달하여
익셉션을 발생하지 않게하고. 빈이 존재하면 해당 빈을 값으로 갖는 Optional을 인자로 전달한다.

세번 째 방법으로는 @Nullable이 있다. Nullable에노테이션을 의존 주입할 파라미터에 붙이면 빈이 존재하면 해당 빈을
인자로하고 존재하지 않으면 null을 전달한다.

@Autowired(required=false)와 @Nullable의 차이는 세터메소드 호출에 있다.
@Nullable의 경우에는 빈이 없어도 호출은 하고 required는 호출자체를 안한다.
필드에도 적용된다.
required는 인자를 null로 전달도 안하고 @Nullable은 null로 전달을 한다. 
required는 값자체를 할당하지 않는다.

@Component
Component("infoPrinter") 처럼 컴포넌트에 값을 주었을 경우 값이 빈의 이름이 되고 값을 주지 않았을 경우엔
클래스에 첫 글자를 소문자로 바꾼 이름을 빈 이름으로 사용한다.
@Component스캔에서 제외 시키고 싶다면 excludeFilters 속성을 사용하면 된다.

기본스캔대상
@Component
@Contoller
@Service
@Repository
@Aspect
@Configuration

@Component  로 자동등록한 빈과 @Bean으로 수동등록한 빈 의 이름이 같다면
수동등록한 빈이 우선이다. 이름이 다르다면 둘다 생성된다,
@Qualifier로 적절하게 사용해야 한다.

빈 객체의 초기화와 소멸 : 스프링 인터페이스
스프링의 InitalizingBean 인터페이스를 구현한 afterPropertiesSet()메소드를 알맞게 구현해서 빈을 초기화 한다.
스프링의 DisposableBean 인터페이스를 구현한 destory()메소드를 알맞게 구현해서 빈을 소멸시킨다.
데이터베이스 커넥션 풀에서 사용된다. 또 채팅클라이언트에서 사용된다.

빈을 싱글톤범위가 아닌 프로토타입으로 지정하면 빈 객체를 구할 때마다 매번 새로운 객체를 생성한다.
@Scope("prototype")으로 설정하면 된다. 명시적으로 "singleton"을 사용해도 된다.
프로토타입 객체를 생성했을 시엔 소멸 처리를 코드에서 직접해야 한다.

핵심 기능의 실행은 다른 객체에 위임하고 부가적인 기능을 제공하는 객체를 프록시(proxy)라고 부른다.
실제 핵심 기능을 실행하는 객체는 대상 객체라고 부른다.
프록시의 특징은 핵심기능을 구현하지 않는다는 점이다. 대신 여러 객체에 공통으로 적용할 수 있는 기능을 구현한다.

AOP(Aspect Oriented Programming)
여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법.
핵심 기능과 공통 기는의 구현을 분리함으로써 핵심 기능을 구현한 코드의 수정 없이 공통 기능을 적용 할 수 있게 만듦.

DB 커넥션 풀
일정 개수의 DB커넥션을 미리 만들어두는 기법
사용자가 올때마다 만들면 시간이 오래걸리고 DBMS에 부하를 준다.
커넥션풀에서 커넥션을 가져와 사용한 뒤 커넥션을 다시 풀에 반납한다.

Servlet
클라이언트가 어떠한 요청을 하면 그에 대한 결과를 전송해주는 역할


